//Gotta put this in gitignore

### Why does ebpf need us to lock the RAM?

- In Linux kernel, certain paths are critical paths that the kernel treats as high priority.
- We are hooking into these criticial paths (like recieving a packet)
- So when the kernel waits for our code to be swapped back in from the SSD the entire device hangs
- Wow. 

### Where did monitorObjects come from?

- On running `go generate ./...`, a tool called bpf2go reads the C code and automatically writes a new file called monitor_bpfel.go.
- Inside this file the tool creates a struct called monitorObjects.
- Because this file is in the same package name, we can directly access it.

### What is monitorObjects?

- a struct
- Our C code in this case has a function (handle_packet) and a map (my_ringbuf), then the struct stores one container for C functions and one for BPF Maps/Ringbufs
- 
```
type monitorObjects struct {
    MonitorPrograms // Container for your C functions
    MonitorMaps     // Container for your BPF Maps/Ringbufs
}
```
### What is loadMonitorObjects?

- Also generated by bpf2go
- Does three main things-
1. Loading: the C bytecode is pushed to the kernel which then runs the Verifier.
2. Allocates space for Maps that the C code might have defined in the RAM and locks the memory for it.
3. Wiring: The function takes the pointers (File Descriptors) to the programs and maps that the kernel just created and "plugs" them into our objs struct.
- After this function runs, our objs.MyRingBuf is no longer empty; it is now a live "pipe" connected directly to the kernel's memory.

### Why are we even loading RawBytes from C into Go when Go is essentially just logging packets being dropped and doesn't need to compile and send things to the kernel?

- Portability: prevents us form having to carry .o files around, just compile the one Go file on any OS/device and boom.
- Kernel Translator: If we compile the C code on my laptop and move the raw binary to a server, it will crash or report garbage data because the memory addresses won't match. 
- bf2go fixes this by looking at the specific kernel running on the machine rn, reading it's BTF (BPF Type Format) data from that kernel (the kernel's own map of its structures), and rewrites the C bytecode on the fly to point to the correct memory offsets before pushing it into the kernel.

### How does the C to Go flow work?

- We write the logic in C which has instructions for the kernel
- Running `go generate` triggers a compiler (Clang) which turns the C code into eBPF Bytecode.
- This Bytecode is stored in an ELF object file (monitor_bpfle.o in our case).
- The Bytecode is embedded into a Go variable: bpf2go reads the .o file and copy pastes the binary data into a brand new Go soruce file as a long slice of bytes. (`monitorBytes` in monitor_bpfle.go here).
- Now upon `go build` this bytecode will be built into our final Go executable.
- Then `main.go` starts and calls loadMonitorObjects() which takes monitorBytes slice and hands it to Linux Kernel via bpf() system call. The Verifier runs. 
- Kernel's JIT (Just-In-Time) Compiler converts the generic eBPF code into specific machine code based on the CPU.


### What are `monitor_bpfle.o` and `monitor_bpfle.go` files?
- C to Bytecode: bpf2go calls a C compiler (Clang) to turn your .c file into monitor_bpfel.o. This is raw machine code for the eBPF virtual machine.
- The Embedding: bpf2go then creates monitor_bpfel.go. This file uses a special Go directive called //go:embed.
- The "Big Build": When you run go build, the Go compiler sees that //go:embed directive. It reaches out, grabs the binary data inside monitor_bpfel.o, and shoves it directly into your final Go executable.

### What is a Tracepoint?
